'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Status = undefined;

var _react = require('react');

var React = _interopRequireWildcard(_react);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Status = exports.Status = Object.freeze({
  in: 'in', // Child is animating in
  out: 'out', // Child is animating out
  static: 'static' // Child is from initial render or have animated in
});

/**
 * Core merging algorithm: Topological sorting (https://en.wikipedia.org/wiki/Topological_sorting)
 *
 * If previous keys are [A, C] and the next render keys are [B, C, D], the merged keys should have
 * - A, B must be before C, order of A and B can be ambiguous
 * - D must be after C
 *
 * The result here could either be [A, B, C, D] or [B, A, C, D]. We will choose to always prioritize previous keys, so the final result here will be [A, B, C, D].
 *
 * We picked to use an insertion sort instead of Kahn's algorithm and can achieve closely O(n+m) complexity for the following reasons:
 * 1. Essentially we are merging only two path.
 * 2. The children we recieved from both render are already in order.
 * 3. Most use cases for this function will have a diff that is limited in size. (add/remove one item)
 *
 * However, note that the complexity can be O(n*m) in the case that there are no similarities between the two input lists.
 */
exports.default = function (prevChildren, nextChildren) {
  var nextChildIndex = 0;
  var prevChildIndex = 0;
  var mergedChildren = [];

  var _loop = function _loop() {
    if (nextChildIndex >= nextChildren.length) {
      // in this case, we've exhausted all next children and merge the rest of prev children
      mergedChildren.push.apply(mergedChildren, _toConsumableArray(prevChildren.slice(prevChildIndex).map(function (child) {
        return { child: child, status: Status.out };
      })));
      return 'break';
    }
    var nextChild = nextChildren[nextChildIndex];
    var prevChild = prevChildren[prevChildIndex];

    if (nextChild.key === prevChild.key) {
      // if keys are equal, the child is static and has not transitioned between states
      mergedChildren.push({ child: nextChild, status: Status.static });
      nextChildIndex++;
    } else {
      // otherwise, we check for membership of prevChild in nextChildren
      var prevChildIndexInNextChildren = nextChildren.findIndex(function (child) {
        return child.key === prevChild.key;
      });
      if (prevChildIndexInNextChildren >= 0) {
        // if prevChild is in nextChildren, then the elements between nextChildIndex and prevChildIndexInNextChildren are transitioning in; thus we insert them
        // and we also push the matching prevChild and nextChild at prevChildIndexInNextChildren + 1
        // then move the indices accordingly.
        mergedChildren.push.apply(mergedChildren, _toConsumableArray(nextChildren.slice(nextChildIndex, prevChildIndexInNextChildren).map(function (child) {
          return { child: child, status: Status.in };
        })).concat([{ child: nextChildren[prevChildIndexInNextChildren], status: Status.static }]));
        // Push the prevChild (also nextChildren at prevChildIndexInNextChildren)
        nextChildIndex = prevChildIndexInNextChildren + 1;
      } else {
        // if prevChild is not in next children, that child is leaving.
        mergedChildren.push({ child: prevChild, status: Status.out });
      }
    }
    prevChildIndex++;
  };

  while (prevChildIndex < prevChildren.length) {
    var _ret = _loop();

    if (_ret === 'break') break;
  }

  if (nextChildIndex < nextChildren.length) {
    // in this case, we've exhausted all prev children and merge the rest of next children
    mergedChildren.push.apply(mergedChildren, _toConsumableArray(nextChildren.slice(nextChildIndex).map(function (child) {
      return { child: child, status: Status.in };
    })));
  }

  return mergedChildren;
};